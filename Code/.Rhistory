scale_color_manual(values = colors) +
ggtitle(bma$labels[i]))
}
#Generate function "posterior.ggPlot"
#This function generates a posterior and posterior predictive probability density plot
#xmin and xmax to scale the x-axis
#bma has to be a bayesmeta object
posterior.ggplot <- function(xmin, xmax, bma) {
effect <- seq(xmin, xmax, length = 200)
colors <- c("posterior" = "red", "posterior predictive" = "blue")
devAskNewPage(ask = FALSE)
ggplot(data = NULL, aes(x=effect,y=bma$dposterior(mu = effect))) +
geom_line(aes(x = effect, y = bma$dposterior(mu = effect), col = "posterior (?)")) +
geom_line(aes(x = effect, y = bma$dposterior(mu = effect, predict = T), col = "posterior predictive (???k+1)")) +
geom_vline(xintercept = 0, col = "gray") +
theme_minimal_hgrid(12) +
labs(x = "effect", y = "probability density", color = "legend") +
scale_color_manual(values = colors)
}
#Generate function "priorposteriorlikelihood.ggplot"
priorposteriorlikelihood.ggplot <- function(bma) {
effect <- seq(-2, 2, length = 200)
colors <- c("posterior (?)" = "#D55E00", "prior (?)" = "#009E73", "likelihood" = "#0072B2")
devAskNewPage(ask = FALSE)
ggplot(data = NULL, aes(x=effect,y=bma$dposterior(mu = effect))) +
geom_line(aes(x = effect, y = bma$likelihood(mu = effect), col = "likelihood")) +
geom_line(aes(x = effect, y = bma$dposterior(mu = effect), col = "posterior (?)")) +
geom_line(aes(x = effect, y = bma$dprior(mu = effect), col = "prior (?)")) +
geom_vline(xintercept = 0, col = "gray") +
theme_minimal_hgrid(12) +
labs(x = "effect", y = "probability density", color = "legend") +
scale_color_manual(values = colors)
}
#Generate function "tauprior.ggplot"
tauprior.ggplot <- function(bma) {
effect <- seq(0, 2, length = 200)
devAskNewPage(ask = FALSE)
ggplot(data = NULL, aes(x=effect,y=bma$dprior(tau = effect))) +
geom_line(aes(x = effect, y = bma$dprior(tau = effect))) +
geom_vline(xintercept = 0, col = "gray") +
theme_minimal_hgrid(12) +
labs(x = "tau", y = "probability density")
}
#Generate function "bayesmeta.master"
#This function does the full analysis for a whole dataset/subset:
#aggregation of effect sizes
#summary of results
#plots
bayesmeta.master <- function(data) {
#Aggregate within study effect sizes
aggES <<- agg(id     = Paper.No,
es     = yi,
var    = vi,
data   = data,
cor = .5,
method = "BHHR")
#Merging aggregated ES with original dataframe
MA <<- merge(x = aggES, y = data, by.x = "id", by.y = "Paper.No")
MA <<- unique(setDT(MA) [sort.list(id)], by = "id")
MA <<- with(MA, MA[order(MA$es)])
#Generate bayesmeta-object "bma", which stores all relevant results
bma <<- bayesmeta(y = MA$es,sigma = sqrt(MA$var), labels = MA$study,
tau.prior = function(t) dhalfnormal(t, scale = 0.5),
mu.prior.mean = 0, mu.prior.sd = 4)
#Show summary of "bma"
summary(bma)
#ggPlot: Prior, posterior, and likelihood
print(priorposteriorlikelihood.ggplot(bma))
#ggPlot: Original and shrinkage estimates for the all studys seperatly
for (study in c(1:nrow(MA))){
shrinkage.ggplot(data = bma, i=study)
}
#ggPlot: Posterior and posterior predictive probability density plot
print(posterior.ggplot(-1,1,bma))
#Generate basic plots
forestplot.bayesmeta(bma)
plot(bma, which=2)
plot(bma, which=3)
plot(bma, which=4)
}
# BF robustness check
robustness <- function(MA,SD, tauprior) {
narrow <- bayesmeta(y = MA$es,sigma = sqrt(MA$var), labels = MA$study,
tau.prior = tauprior,
mu.prior = c("mean" = 0, "sd" = (SD/2)))
user <- bayesmeta(y = MA$es,sigma = sqrt(MA$var), labels = MA$study,
tau.prior = tauprior,
mu.prior = c("mean" = 0, "sd" = SD))
wide <- bayesmeta(y = MA$es,sigma = sqrt(MA$var), labels = MA$study,
tau.prior = tauprior,
mu.prior = c("mean" = 0, "sd" = SD+1))
ultrawide <- bayesmeta(y = MA$es,sigma = sqrt(MA$var), labels = MA$study,
tau.prior = tauprior,
mu.prior = c("mean" = 0, "sd" = SD+2))
BFS <- c(user$bayesfactor[2,2], narrow$bayesfactor[1,2], user$bayesfactor[1,2], wide$bayesfactor[1,2], ultrawide$bayesfactor[1,2])
SDS <- c(0.01,SD/2,SD,SD+1,SD+2)
names <- c("Min", "Narrow", "User","Wide","Ultrawide")
ggplot(data = NULL, aes(SDS,BFS)) +
geom_hline(yintercept = 3, color = "grey", size = 0.3, alpha = .6) +
geom_hline(yintercept = 10, color = "grey", size = 0.3, alpha = .6) +
geom_hline(yintercept = 20, color = "grey", size = 0.3, alpha = .6) +
geom_hline(yintercept = 30, color = "grey", size = 0.3, alpha = .6) +
geom_point(aes(SDS,BFS), show.legend = c("max","user","wide","ultrawide"), alpha = .75) +
scale_x_continuous(breaks = c(SDS), limits = c(0,SDS[5]+3)) +
scale_y_continuous(limits = c(0,BFS[5]+10)) +
geom_line(aes(SDS,BFS), alpha = .4) +
geom_text(aes(label = names),vjust = -1) +
labs(x = "standard deviations", y = "BF01") +
theme_cowplot(12) +
annotate("text", label = "Anecdotal evidence for H0", x = SDS[5] + 2, y = 6.5) +
annotate("text", label = "Substantial evidence for H0", x = SDS[5] + 2, y = 15) +
annotate("text", label = "Strong evidence for H0", x = SDS[5] + 2, y = 25) +
annotate("text", label = "Strong evidence for H0", x = SDS[5] + 2, y = (BFS[5]+10+30)/2) +
annotate("text", label = "Anecdotal evidence for H1", x = SDS[5] + 2, y = 0)
}
################### Helper functions for frequentist analysis#########################
#Meta analysis regression with summary, forest and funnel plot
myMareg <- function(formula = es~1,
var = var,
data,
addfit_forest = T) {
model <- mareg(formula = formula,
var = var,
data = data,
slab = data$study)
result <- list(summary(model),
confint(model),
metafor::forest.rma(x = model, showweights = T, addfit = addfit_forest,
order = "obs",
xlim=c(-10,8)),
funnel(model, xlab = "Observed outcome"))
listnames <- c("Modelsummary", "Model-Fit", "Forestplot", "Funnelplot")
names(result) <- listnames
return(result)
}
#Coefficients table
myCoef <- function(coef){
coef<-round(coef,digits = 3)
DT::datatable(coef,
rownames=c("Intercept"),
colnames=c("b","S.E.","z","lower CI","upper CI","p"))
}
#Model fit
myFit <- function(fit){
fit<-round(fit,digits = 3)
DT::datatable(fit)
}
#Model uniqueness
myUni<-function(rand){
uni<-as.data.frame(rand)
uni$estimate<-round(uni$estimate,digits = 2)
uni$ci.lb<-round(uni$ci.lb,digits = 2)
uni$ci.ub<-round(uni$ci.ub,digits = 2)
DT::datatable(uni,
colnames = c("estimate","lower CI","upper CI"))
}
#######################################################################################
################### EFFECT OF taVNS ON HRV - A BAYSIAN META-ANALYSIS ##################
#######################################################################################
################### Shiny App v.2 20.08.2020 SERVER ###################################
# Initialize #----
rm(list=ls())
if (!require("pacman")) install.packages("pacman")
pacman::p_load(bayesmeta, cowplot, dplyr, DT, esc, data.table,
ggplot2, knitr, MAd, readr, readxl, R.rsp, shiny,
shinycssloaders, shinythemes, stringr, tidyr, xtable)
load(file = "df.RDa")
load(file = "screened.RDa")
source("HelperFunctions.R")
#----
# Define server logic
server <- function(input, output) {
# Create parameter reactive for HRV parameter columns in study overview
parameters <- reactive({input$hrvparam})
# Create MA reactive for all outputs
MA <- reactive({
# Create subset based on chosen inclusion criteria
df_sub <- df %>% filter(df$Design %in% input$design
& df$HRV.Parameter %in% input$hrvparam
& df$Sample %in% input$sample
& df$Age.Category %in% input$age
& df$Blindness %in% input$blind
& df$Stimulation.side %in% input$side
& df$Publication.Year >= input$pubyear
& df$Control.Type %in% input$control
& df$Part.of.the.ear.stimulated %in% input$part
& df$Intensity.fixed.or.mean %in% input$intensity1
& df$Mean.Intensity..mA. >= input$intensity2
& df$Stimulation.duration.sec. >= input$stimduration
& df$taVNS.Device %in% input$device
& df$study %in% input$included)
# Aggregate effect sizes
aggES <- agg(id     = Paper.No,
es     = yi,
var    = vi,
data   = df_sub,
cor = .5,
method = "BHHR")
# Merging aggregated ES with original dataframe
MA <- merge(x = aggES, y = df_sub, by.x = "id", by.y = "Paper.No")
MA <- unique(setDT(MA) [sort.list(id)], by = "id")
MA <- with(MA, MA[order(MA$es)])
})
# Create bma reactive for all outputs
bma <- reactive({
# Generate bayesmeta-object "bma", which stores all relevant results, depending on tau prior chosen
if (input$tauprior == "Half cauchy") {
bma <- bayesmeta(y = MA()$es,sigma = sqrt(MA()$var), labels = MA()$study,
tau.prior = function(t) dhalfcauchy(t, scale = input$scaletau),
mu.prior = c("mean" = input$mupriormean, "sd" = input$mupriorsd))
} else if (input$tauprior == "Half student t") {
bma <- bayesmeta(y = MA()$es,sigma = sqrt(MA()$var), labels = MA()$study,
tau.prior = function(t) dhalfnormal(t, scale = input$scaletau),
mu.prior = c("mean" = input$mupriormean, "sd" = input$mupriorsd))
} else {
bma <- bayesmeta(y = MA()$es,sigma = sqrt(MA()$var), labels = MA()$study,
tau.prior = input$tauprior,
mu.prior = c("mean" = input$mupriormean, "sd" = input$mupriorsd))
}
})
# Study overview
output$studies <- DT::renderDataTable({
MA <- as.data.frame(MA())
MA <- MA %>% mutate_if(is.numeric, round, digits=3)
parameters <- base::subset(MA, select = c(parameters()))
criteria <- base::subset(MA, select = c(study, es, var, Design, Sample, Age.Category, Blindness, Total.N, Stimulation.side, Part.of.the.ear.stimulated, taVNS.Device, Comment))
colnames(criteria) <- c("Study", "Hedges' g", "Variance", "Design", "Sample", "Age group", "Blindness", "Total N", "Stimulation side", "Stimulation site", "taVNS device", "Comment")
MAclean <- cbind(criteria,parameters)
DT::datatable(MAclean,
options = list(dom = 't',
pageLength = nrow(MAclean)))
})
# Warning message if 3 or less studies are included
output$warning <- renderPrint({
MA <- as.data.frame(MA())
if (nrow(MA) < 4) {print('WARNING: With the chosen inclusion criteria, 3 or less studies will be included in the analysis.')}
})
# Forest Plot
output$forest <- renderPlot({
forestplot.bayesmeta(bma(), xlab = "Hedges' g")
}, height = 800)
# Funnel Plot
output$funnel <- renderPlot({
funnel.bayesmeta(bma(), main = "")
})
# Statistics
output$bf <- renderPrint ({
bma()$bayesfactor[1,]
})
output$summary <- renderPrint({
bma()$summary
})
output$ML <- renderPrint({
bma()$ML
})
output$MAP <- renderPrint({
bma()$MAP
})
# Full texts screened
output$screened <- DT::renderDataTable({
datatable(screened, options = list(columnDefs = list(list(
targets = 2,
render = JS(
"function(data, type, row, meta) {",
"return type === 'display' && data != null && data.length > 30 ?",
"'<span title=\"' + data + '\">' + data.substr(0, 30) + '...</span>' : data;",
"}")
))),
class = "display")
})
# Additional plots
output$evupdate <- renderPlot({
priorposteriorlikelihood.ggplot(bma())
}, width = 800)
output$joint <- renderPlot({
plot.bayesmeta(bma(), which=2, main = "")
}, width = 800)
output$taupriorplot <- renderPlot({
tauprior.ggplot(bma())
}, width = 800)
output$robustplot <- renderPlot({
if (input$robust == "Yes" &
input$tauprior == "Half cauchy") {
robustness(MA(),SD = input$mupriorsd, tauprior = function(t) dhalfcauchy(t, scale = input$scaletau))
} else if (input$robust == "Yes" &
input$tauprior == "Half student t") {
robustness(MA(),SD = input$mupriorsd, tauprior = function(t) dhalfnormal(t, scale = input$scaletau))
}
}, width = 800)
}
runApp()
#######################################################################################
################### EFFECT OF taVNS ON HRV - A BAYSIAN META-ANALYSIS ##################
#######################################################################################
################### Main Effect Meta Analysis #########################################
#----
#Clear global environment and load required packages
rm(list=ls())
dev.off()
if (!require("pacman")) install.packages("pacman")
pacman::p_load(bayesmeta, car, compute.es, cowplot, data.table, dplyr, esc, forestplot,
ggplot2, knitr, MAd, metafor, outliers, reactable, readr, readxl,
R.rsp, sjPlot, stringr, tidyr)
#Source helper functions
source("HelperFunctions.R")
#Load "df.RDa"
load(file = "df.RDa")
#Filter sham and healthy samples
df <- df %>% filter(df$Sample %in% "healthy"
& df$Control.Type %in% "sham")
#Aggregate within study effect sizes
aggES <- agg(id     = df$Paper.No,
es     = yi,
var    = vi,
data   = df,
cor = .5,
method = "BHHR")
#Merging aggregated ES with original dataframe
MA <- merge(x = aggES, y = df, by.x = "id", by.y = "Paper.No")
MA <- unique(setDT(MA) [sort.list(id)], by = "id")
MA <- with(MA, MA[order(MA$es)])
#write_delim(MA, "~/Documents/Uni Salzburg/Praktikum Master/MA_taVNS_HR/MA_R_Project/DF4jasp.csv", delim = ";")
#Generate bayesmeta-object "bma", which stores all relevant results
bma <- bayesmeta(y = MA$es,sigma = sqrt(MA$var), labels = MA$study,
tau.prior = function(t) dhalfcauchy(t, scale = 0.5),
mu.prior = c("mean" = 0, "sd" = 1.5))
#Robustness check
robustness(MA, 1.5, function(t) dhalfcauchy(t, scale = 0.5))
#Summary tables
summary(bma)
#Plot: Original and shrinkage estimates for the all studys separatly
#for (study in c(1:nrow(MA))){
# shrinkage.ggplot(data = bma, i=study)
#}
#Plot: Prior, posterior and likelihood
priorposteriorlikelihood.ggplot(bma)
#ggPlot: Posterior and posterior predictive probability density plot
posterior.ggplot(-1,1,bma)
#Generate basic plots
forestplot.bayesmeta(bma)
plot(bma, which=2)
plot(bma, which=3)
plot(bma, which=4)
#Funnel plot
funnel.bayesmeta(bma, main = "")
#Study weights
bma$weights
#Posterior predicitve p values
#pppvalue(bma, n = 20, alternative = "two.sided")
#Overview table 1
overview<-data.frame(MA[,c(6, 67, 14, 17,20,24,25)])
#Check for outliers
Boxplot(MA$es, ylab = "Hedges' g", id = F)
################### Main Effect Meta Analysis #########################################
#----
#Clear global environment and load required packages
rm(list=ls())
dev.off()
if (!require("pacman")) install.packages("pacman")
pacman::p_load(bayesmeta, car, compute.es, cowplot, data.table, dplyr, esc, forestplot,
ggplot2, knitr, MAd, metafor, outliers, reactable, readr, readxl,
R.rsp, sjPlot, stringr, tidyr)
#Source helper functions
source("HelperFunctions.R")
#Load "df.RDa"
load(file = "df.RDa")
#Filter sham and healthy samples
df <- df %>% filter(df$Sample %in% "healthy"
& df$Control.Type %in% "sham")
#Aggregate within study effect sizes
aggES <- agg(id     = df$Paper.No,
es     = yi,
var    = vi,
data   = df,
cor = .5,
method = "BHHR")
#Merging aggregated ES with original dataframe
MA <- merge(x = aggES, y = df, by.x = "id", by.y = "Paper.No")
MA <- unique(setDT(MA) [sort.list(id)], by = "id")
MA <- with(MA, MA[order(MA$es)])
#Generate bayesmeta-object "bma", which stores all relevant results
bma <- bayesmeta(y = MA$es,sigma = sqrt(MA$var), labels = MA$study,
tau.prior = function(t) dhalfcauchy(t, scale = 0.5),
mu.prior = c("mean" = 0, "sd" = 1.5))
#Summary tables
summary(bma)
#Plot: Prior, posterior and likelihood
priorposteriorlikelihood.ggplot(bma)
#Plot: Prior, posterior and likelihood
priorposteriorlikelihood.ggplot(bma)
#ggPlot: Posterior and posterior predictive probability density plot
posterior.ggplot(-1,1,bma)
#ggPlot: Posterior and posterior predictive probability density plot
posterior.ggplot(-1,1,bma)
#Generate basic plots
forestplot.bayesmeta(bma)
plot(bma, which=2)
plot(bma, which=3)
plot(bma, which=4)
#Funnel plot
funnel.bayesmeta(bma, main = "")
#Study weights
bma$weights
#Overview table 1
overview<-data.frame(MA[,c(6, 67, 14, 17,20,24,25)])
#Check for outliers
Boxplot(MA$es, ylab = "Hedges' g", id = F)
#Check for outliers
a <- Boxplot(MA$es, ylab = "Hedges' g", id = F)
outliernames <- cbind(rownames(MA)[a],MA[a,6])
outliernames <- cbind(outliernames, MA[a,2])
outliernames <- outliernames %>% mutate_if(is.numeric, round, digits=3)
datatable(outliernames, colnames = c("ID","Study", "Hedges' g"), rownames = F,
options = list(dom = 't',
pageLength = nrow(outliernames)))
DT::datatable(outliernames, colnames = c("ID","Study", "Hedges' g"), rownames = F,
options = list(dom = 't',
pageLength = nrow(outliernames)))
#Check for outliers
a <- Boxplot(MA$es, ylab = "Hedges' g", id = F)
outliernames <- cbind(rownames(MA)[a],MA[a,6])
outliernames <- cbind(outliernames, MA[a,2])
outliernames <- outliernames %>% mutate_if(is.numeric, round, digits=3)
DT::datatable(outliernames, colnames = c("ID","Study", "Hedges' g"), rownames = F,
options = list(dom = 't',
pageLength = nrow(outliernames)))
MAoutliersremoved <- MA[-1,] # Gancheva2018
boxplot(MAoutliersremoved$es)
#Normality
hist(MA$es)
#Check for outliers
a <- Boxplot(MA$es, ylab = "Hedges' g", id = F)
#Check for outliers
a <- car::Boxplot(MA$es, ylab = "Hedges' g", id = F)
#Check for outliers
a <- car::Boxplot(MA$es, ylab = "Hedges' g", id = T)
outliernames <- cbind(rownames(MA)[a],MA[a,6])
outliernames <- cbind(outliernames, MA[a,2])
outliernames <- outliernames %>% mutate_if(is.numeric, round, digits=3)
DT::datatable(outliernames, colnames = c("ID","Study", "Hedges' g"), rownames = F,
options = list(dom = 't',
pageLength = nrow(outliernames)))
MAoutliersremoved <- MA[-1,] # Gancheva2018
boxplot(MAoutliersremoved$es)
#Normality
hist(MA$es)
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = T)
pacman::p_load(bayesmeta, car, compute.es, cowplot, data.table, dplyr, esc, forestplot,
ggplot2, ggstatsplot, knitr, MAd, metafor, outliers, reactable, readr, readxl,
R.rsp, sjPlot, stringr, tidyr)
#Normality
gghistostats(MA, es)
#Normality
gghistostats(MA, es)
ggbetweenstats(MA, Control.Type, es)
ggbetweenstats(MA, Design, es)
ggbetweenstats(MA, Design, es)
ggbetweenstats(MA, Design, es, plot.type = "box")
ggbetweenstats(MA, Design, es, plot.type = "box",
outlier.tagging = T,
outlier.label = study)
ggbetweenstats(MA, Design, es, plot.type = "box",
outlier.tagging = T,
outlier.label = study,
ylab = "Hedges' g")
#Normality
gghistostats(MA, es)
#Normality
gghistostats(MA, es, xlab = "Hedges' g", ggtheme = cowplot::theme_cowplot(12))
#Normality
gghistostats(MA, es, xlab = "Hedges' g", ggtheme = cowplot::theme_minimal_hgrid(12))
#Normality
gghistostats(MA, es, xlab = "Hedges' g",
ggtheme = cowplot::theme_minimal_hgrid(12))
ggbetweenstats(MA, Design, es, plot.type = "box",
outlier.tagging = T,
outlier.label = study,
ylab = "Hedges' g")
#Normality
gghistostats(MA, es, xlab = "Hedges' g", ylab = "Coung"
ggtheme = cowplot::theme_minimal_hgrid(12))
#Normality
gghistostats(MA, es, xlab = "Hedges' g", ylab = "Count",
ggtheme = cowplot::theme_minimal_hgrid(12))
#Normality
gghistostats(MA, es, xlab = "Hedges' g", ylab = "Count",
ggtheme = cowplot::theme_minimal_hgrid(12))
#Normality
gghistostats(MA, es, xlab = "Hedges' g", ylab = "Frequency",
ggtheme = cowplot::theme_minimal_hgrid(12))
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
#if (!require("pacman")) install.packages("pacman")
library(bayesmeta, car, cowplot, dplyr, DT, esc, data.table,
ggplot2, knitr, MAd, readr, readxl, R.rsp, shiny,
shinycssloaders, shinythemes, stringr, tidyr, xtable)
#if (!require("pacman")) install.packages("pacman")
library(c(bayesmeta, car, cowplot, dplyr, DT, esc, data.table,
ggplot2, knitr, MAd, readr, readxl, R.rsp, shiny,
shinycssloaders, shinythemes, stringr, tidyr, xtable))
shiny::runApp()
